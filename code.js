// Generated by CoffeeScript 1.6.3
(function() {
  var Board, Canvas, Food, Game, Point, Snake, SnakeBrain, SnakeSegment, backgroundColor, checkColor, currentFrame, foodColor, headColor, height, history, randomInt, snakeColor, width,
    __hasProp = {}.hasOwnProperty;

  width = 60;

  height = 40;

  backgroundColor = 'white';

  headColor = 'red';

  snakeColor = 'green';

  foodColor = 'orange';

  checkColor = 'blue';

  history = null;

  currentFrame = 9999999999;

  randomInt = function(lower, upper) {
    var start;
    start = Math.random();
    return Math.floor(start * (upper - lower + 1) + lower);
  };

  Board = (function() {
    function Board() {
      var row, _, _i, _j;
      this.notes = '';
      this.array = [];
      for (_ = _i = 0; 0 <= height ? _i < height : _i > height; _ = 0 <= height ? ++_i : --_i) {
        row = [];
        for (_ = _j = 0; 0 <= width ? _j < width : _j > width; _ = 0 <= width ? ++_j : --_j) {
          row.push(0);
        }
        this.array.push(row);
      }
    }

    Board.prototype.clear = function() {
      var x, y, _i, _results;
      _results = [];
      for (y = _i = 0; 0 <= height ? _i < height : _i > height; y = 0 <= height ? ++_i : --_i) {
        _results.push((function() {
          var _j, _results1;
          _results1 = [];
          for (x = _j = 0; 0 <= width ? _j < width : _j > width; x = 0 <= width ? ++_j : --_j) {
            _results1.push(this.set(x, y, 0));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Board.prototype.get = function(x, y) {
      return this.array[y][x];
    };

    Board.prototype.set = function(x, y, value) {
      return this.array[y][x] = value;
    };

    Board.prototype.paintClosedArea = function(point) {
      var _ref;
      if (point.x < 0 || point.x >= width) {
        return;
      }
      if (point.y < 0 || point.y >= height) {
        return;
      }
      if ((_ref = this.get(point.x, point.y)) !== 0 && _ref !== 3) {
        return;
      }
      this.set(point.x, point.y, 4);
      this.paintClosedArea(new Point(point.x, point.y + 1));
      this.paintClosedArea(new Point(point.x, point.y - 1));
      this.paintClosedArea(new Point(point.x + 1, point.y));
      return this.paintClosedArea(new Point(point.x - 1, point.y));
    };

    Board.prototype.countBlueOnes = function() {
      var result, x, y, _i, _j;
      result = 0;
      for (y = _i = 0; 0 <= height ? _i < height : _i > height; y = 0 <= height ? ++_i : --_i) {
        for (x = _j = 0; 0 <= width ? _j < width : _j > width; x = 0 <= width ? ++_j : --_j) {
          if (this.get(x, y) === 4) {
            result++;
            this.set(x, y, 0);
          }
        }
      }
      return result;
    };

    return Board;

  })();

  Canvas = (function() {
    Canvas.prototype.width = width * 10;

    Canvas.prototype.height = height * 10;

    function Canvas() {
      this.canvas = document.getElementById('myCanvas');
      this.ctx = this.canvas.getContext('2d');
    }

    Canvas.prototype.clear = function() {
      this.ctx.fillStyle = backgroundColor;
      return this.ctx.fillRect(0, 0, this.width, this.height);
    };

    Canvas.prototype.paint = function(board) {
      var x, y, _i, _results;
      _results = [];
      for (y = _i = 0; 0 <= height ? _i < height : _i > height; y = 0 <= height ? ++_i : --_i) {
        _results.push((function() {
          var _j, _results1;
          _results1 = [];
          for (x = _j = 0; 0 <= width ? _j < width : _j > width; x = 0 <= width ? ++_j : --_j) {
            switch (board.get(x, y)) {
              case 1:
                this.ctx.fillStyle = snakeColor;
                break;
              case 2:
                this.ctx.fillStyle = headColor;
                break;
              case 3:
                this.ctx.fillStyle = foodColor;
                break;
              case 4:
                this.ctx.fillStyle = checkColor;
                break;
              default:
                this.ctx.fillStyle = backgroundColor;
            }
            _results1.push(this.ctx.fillRect(x * 10, y * 10, 10, 10));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    return Canvas;

  })();

  Point = (function() {
    function Point(x, y) {
      this.x = x;
      this.y = y;
    }

    return Point;

  })();

  Food = (function() {
    function Food(x, y, value) {
      this.x = x;
      this.y = y;
      this.value = value != null ? value : 3;
    }

    Food.prototype.project = function(board) {
      return board.set(this.x, this.y, 3);
    };

    return Food;

  })();

  SnakeSegment = (function() {
    function SnakeSegment(x, y, next) {
      this.x = x;
      this.y = y;
      this.next = next != null ? next : null;
    }

    return SnakeSegment;

  })();

  Snake = (function() {
    function Snake(direction) {
      var i, newSegment, segment, _i;
      this.direction = direction != null ? direction : 'right';
      this.head = new SnakeSegment(10, 10);
      segment = this.head;
      for (i = _i = 0; _i <= 3; i = ++_i) {
        newSegment = new SnakeSegment(10, segment.y + 1);
        segment.next = newSegment;
        segment = newSegment;
      }
    }

    Snake.prototype.move = function() {
      var newHead, segment, _results;
      newHead = (function() {
        switch (this.direction) {
          case 'left':
            return new SnakeSegment(this.head.x - 1, this.head.y, this.head);
          case 'right':
            return new SnakeSegment(this.head.x + 1, this.head.y, this.head);
          case 'up':
            return new SnakeSegment(this.head.x, this.head.y - 1, this.head);
          case 'down':
            return new SnakeSegment(this.head.x, this.head.y + 1, this.head);
        }
      }).call(this);
      this.head = newHead;
      if (this.extra > 0) {
        this.extra--;
        return;
      }
      segment = this.head;
      _results = [];
      while (segment) {
        if (segment.next && !segment.next.next) {
          segment.next = null;
          break;
        }
        _results.push(segment = segment.next);
      }
      return _results;
    };

    Snake.prototype.project = function(board) {
      var segment, _results;
      board.set(this.head.x, this.head.y, 2);
      segment = this.head.next;
      _results = [];
      while (segment) {
        board.set(segment.x, segment.y, 1);
        _results.push(segment = segment.next);
      }
      return _results;
    };

    return Snake;

  })();

  SnakeBrain = (function() {
    function SnakeBrain() {}

    SnakeBrain.prototype.checkPointIsOccupied = function(point) {
      if (point.x < 0 || point.x >= width || point.y < 0 || point.y >= height) {
        return true;
      }
      return this.board.get(point.x, point.y) === 1;
    };

    SnakeBrain.prototype.getDistanceToFood = function(point) {
      var dX, dY;
      dX = point.x - this.food.x;
      dY = point.y - this.food.y;
      return dX * dX + dY * dY;
    };

    SnakeBrain.prototype.countNeighbours = function(point) {
      var result;
      result = 0;
      if (this.checkPointIsOccupied(new Point(point.x, point.y + 1))) {
        result++;
      }
      if (this.checkPointIsOccupied(new Point(point.x, point.y - 1))) {
        result++;
      }
      if (this.checkPointIsOccupied(new Point(point.x + 1, point.y))) {
        result++;
      }
      if (this.checkPointIsOccupied(new Point(point.x - 1, point.y))) {
        result++;
      }
      return result;
    };

    SnakeBrain.prototype.think = function(board, snake, food) {
      var directions, distance, key, neighbours, result, value, x, y,
        _this = this;
      this.board = board;
      this.snake = snake;
      this.food = food;
      x = this.snake.head.x;
      y = this.snake.head.y;
      directions = {
        up: new Point(x, y - 1),
        down: new Point(x, y + 1),
        left: new Point(x - 1, y),
        right: new Point(x + 1, y)
      };
      for (key in directions) {
        if (!__hasProp.call(directions, key)) continue;
        value = directions[key];
        if (this.checkPointIsOccupied(value)) {
          delete directions[key];
        }
      }
      result = [];
      for (key in directions) {
        if (!__hasProp.call(directions, key)) continue;
        value = directions[key];
        distance = this.getDistanceToFood(value);
        neighbours = this.countNeighbours(value);
        if (neighbours < 3) {
          result.push([key, distance, value]);
        }
      }
      if (result.length > 1) {
        result = result.filter(function(element) {
          var closed;
          _this.board.paintClosedArea(element[2]);
          closed = _this.board.countBlueOnes();
          _this.board.notes += "" + element[0] + " (" + closed + "), ";
          return closed > 500;
        });
      }
      result.sort(function(a, b) {
        return a[1] - b[1];
      });
      if (result.length > 0) {
        return this.snake.direction = result[0][0];
      }
    };

    return SnakeBrain;

  })();

  Game = (function() {
    function Game() {
      var processCallback;
      history = [];
      this.canvas = new Canvas;
      this.board = new Board;
      this.snake = new Snake;
      this.snake.project(this.board);
      this.food = this.addFood(this.board);
      this.food.project(this.board);
      this.brain = new SnakeBrain(this.board, this.snake, this.food);
      this.canvas.paint(this.board);
      processCallback = this.mainLoop.bind(this);
      this.processing = setInterval(processCallback, 1);
    }

    Game.prototype.mainLoop = function() {
      this.brain.think(this.board, this.snake, this.food);
      if (this.checkCollision(this.board)) {
        this.snake.move();
        return;
      } else {
        this.snake.move();
      }
      this.checkFoodEaten(this.board);
      history.push(this.board);
      this.board = new Board;
      this.snake.project(this.board);
      this.food.project(this.board);
      return this.canvas.paint(this.board);
    };

    Game.prototype.armKeyboard = function() {
      var _this = this;
      return document.addEventListener('keydown', function(e) {
        if (e.keyCode === 37 && _this.snake.direction !== 'right') {
          _this.snake.direction = 'left';
        }
        if (e.keyCode === 39 && _this.snake.direction !== 'left') {
          _this.snake.direction = 'right';
        }
        if (e.keyCode === 38 && _this.snake.direction !== 'down') {
          _this.snake.direction = 'up';
        }
        if (e.keyCode === 40 && _this.snake.direction !== 'up') {
          return _this.snake.direction = 'down';
        }
      });
    };

    Game.prototype.armRewindKeyboard = function() {
      var _this = this;
      document.addEventListener('keydown', function(e) {
        if (e.keyCode === 37) {
          _this.showFrame(-1);
        }
        if (e.keyCode === 39) {
          _this.showFrame(1);
        }
        if (e.keyCode === 38) {
          _this.showFrame(10);
        }
        if (e.keyCode === 40) {
          return _this.showFrame(-10);
        }
      });
      return console.log('keyboard armed for replaying');
    };

    Game.prototype.checkCollision = function(board) {
      var nextHead;
      nextHead = (function() {
        switch (this.snake.direction) {
          case 'up':
            return new Point(this.snake.head.x, this.snake.head.y - 1);
          case 'down':
            return new Point(this.snake.head.x, this.snake.head.y + 1);
          case 'left':
            return new Point(this.snake.head.x - 1, this.snake.head.y);
          case 'right':
            return new Point(this.snake.head.x + 1, this.snake.head.y);
        }
      }).call(this);
      if (nextHead.x < 0 || nextHead.x >= width || nextHead.y < 0 || nextHead.y >= height) {
        this.gameOver();
        return true;
      }
      if (board.get(nextHead.x, nextHead.y) === 1) {
        this.gameOver();
        return true;
      }
      return false;
    };

    Game.prototype.checkFoodEaten = function(board) {
      if (this.snake.head.x === this.food.x && this.snake.head.y === this.food.y) {
        console.log('eaten');
        this.snake.extra = this.food.value;
        return this.food = this.addFood(board);
      }
    };

    Game.prototype.addFood = function(board) {
      var x, y;
      while (true) {
        x = randomInt(0, width - 1);
        y = randomInt(0, height - 1);
        if (board.get(x, y) === 0) {
          return new Food(x, y, 3);
        }
      }
    };

    Game.prototype.gameOver = function() {
      clearInterval(this.processing);
      document.getElementsByTagName('body')[0].className += ' tragedy';
      this.armRewindKeyboard();
      return this.showFrame(0);
    };

    Game.prototype.showFrame = function(delta) {
      var board, historySize;
      historySize = history.length - 1;
      currentFrame += delta;
      if (currentFrame < 0) {
        currentFrame = 0;
      } else if (currentFrame > historySize) {
        currentFrame = historySize;
      }
      board = history[currentFrame];
      this.canvas.paint(board);
      return console.log("" + currentFrame + ": " + board.notes);
    };

    return Game;

  })();

  window.start = function() {
    var game;
    return game = new Game;
  };

}).call(this);

/*
//@ sourceMappingURL=code.map
*/
